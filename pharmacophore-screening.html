<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    Advanced Pharmacophore Screening & Optimization (Commented Version)
    Purpose: Interactive, educational demo for pharmacophore-based ‚Äúfeature matching‚Äù
    Tech: Three.js (r128), Tailwind CSS, OrbitControls
    Notes:
      - This is a concept simulator (not a physics-based docking engine).
      - Score is a simple per-feature distance model (max 25 per target feature, cap 100).
  -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced Pharmacophore Screening & Optimization</title>

  <!-- Tailwind for quick, modern UI styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- three.js core + OrbitControls (r128) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.min.js" defer></script>

  <!-- Inter font for clean typography -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: light; }
    body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
    .canvas-container { background:#111827; border-radius:0.75rem; }
    .feature-card { transition: transform .15s ease, box-shadow .15s ease; }
    .feature-card.matched { background:#10b981; color:#fff; transform:scale(1.04); box-shadow:0 0 14px rgba(16,185,129,.45); }
    .hit-list-row { cursor:pointer; transition: background-color .15s ease; }
    .hit-list-row:hover { background:#2563eb; color:#fff; }
    .loader{ border:4px solid #e5e7eb;border-top:4px solid #3b82f6;border-radius:50%;width:30px;height:30px;animation:spin 1s linear infinite;}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    @media (prefers-reduced-motion: reduce){
      .feature-card{transition:none}
      .loader{animation:none}
    }
  </style>
</head>
<body class="text-gray-800">
  <div class="container mx-auto p-4 max-w-7xl">
    <!-- Page header -->
    <header class="text-center my-6">
      <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Advanced Pharmacophore Screening</h1>
      <p class="text-gray-500 mt-2">Simulating drug discovery with lead identification and optimization.</p>
    </header>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- LEFT: Target list, controls, hit list -->
      <aside class="lg:col-span-1 bg-white p-6 rounded-xl shadow-lg space-y-6">
        <!-- Target features (fixed pharmacophore in this demo) -->
        <section>
          <h2 class="text-xl font-bold mb-2">Target Active Site</h2>
          <div id="target-features-list" class="space-y-2"></div>
        </section>

        <hr/>

        <!-- Controls for screening, optimization, seed toggle, and snapshot -->
        <section>
          <h2 class="text-xl font-bold mb-4">Screening Controls</h2>
          <div class="grid grid-cols-2 gap-2">
            <!-- Screen: generates a new random ligand and scores it -->
            <button id="screen-btn" aria-label="Screen new candidate" class="col-span-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-transform hover:scale-105 shadow-md">
              üß¨ Screen New Candidate
            </button>
            <!-- Optimize: nudges current ligand features slightly (local tweak) -->
            <button id="optimize-btn" aria-label="Optimize current lead" class="hidden col-span-2 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg transition-transform hover:scale-105 shadow-md">
              üß™ Optimize Lead Compound
            </button>
            <!-- Seed toggle: reproducible ‚Äúrandomness‚Äù for demos and grading -->
            <button id="toggle-seed-btn" aria-label="Toggle seeded randomness" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-3 rounded">
              Seeded RNG: ON
            </button>
            <!-- Snapshot: downloads a PNG of the canvas -->
            <button id="snapshot-btn" aria-label="Download canvas snapshot" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-3 rounded">
              üì∏ Snapshot
            </button>
          </div>

          <!-- Loader shown while ‚Äúscreening‚Äù (short simulated delay) -->
          <div id="loader-container" class="hidden flex items-center justify-center mt-4">
            <div class="loader"></div>
            <p class="ml-3 text-gray-600">Screening...</p>
          </div>
        </section>

        <hr/>

        <!-- Hit list with export/import and clear -->
        <section>
          <div class="flex items-center justify-between mb-2">
            <h2 class="text-xl font-bold">üèÜ Screening Hit List</h2>
            <div class="flex gap-2">
              <!-- Export top hits to JSON -->
              <button id="export-btn" aria-label="Export hits as JSON" class="text-xs bg-gray-700 text-white px-2 py-1 rounded">Export</button>
              <!-- Import hits from JSON -->
              <label class="text-xs bg-gray-700 text-white px-2 py-1 rounded cursor-pointer">
                Import<input id="import-input" type="file" accept="application/json" class="hidden" />
              </label>
              <!-- Clear hit list -->
              <button id="clear-btn" aria-label="Clear hits" class="text-xs bg-red-600 text-white px-2 py-1 rounded">Clear</button>
            </div>
          </div>
          <div id="hit-list-container" class="space-y-2">
            <p class="text-sm text-gray-500 text-center py-4">No hits recorded yet.</p>
          </div>
        </section>
      </aside>

      <!-- RIGHT: 3D Canvas + results -->
      <main class="lg:col-span-2 space-y-6">
        <!-- 3D visualization area -->
        <div class="bg-white p-4 rounded-xl shadow-lg">
          <div id="canvas-container" class="w-full h-96 md:h-[520px] relative canvas-container">
            <div class="absolute top-2 left-2 bg-black bg-opacity-50 px-2 py-1 rounded text-white text-xs">
              Drag to rotate ‚Ä¢ Scroll to zoom
            </div>
          </div>
        </div>

        <!-- Results panel: score, match count, per-feature contributions -->
        <div id="results-panel" class="bg-white p-6 rounded-xl shadow-lg hidden">
          <div id="results-content" class="grid grid-cols-1 md:grid-cols-3 gap-6 items-center">
            <div class="md:col-span-1 text-center md:text-left">
              <h3 class="font-semibold text-lg">Binding Affinity Score</h3>
              <p id="score" class="text-6xl font-extrabold text-blue-600">0.00</p>
              <p id="score-interpretation" class="text-gray-600 mt-1">A higher score indicates a better potential match.</p>
              <p id="match-count" class="text-sm text-gray-500 mt-1"></p>
            </div>
            <div class="md:col-span-2">
              <h3 class="font-semibold text-lg mb-2">Ligand Feature Analysis</h3>
              <!-- Cards showing each ligand feature; ‚Äúmatched‚Äù ones are highlighted -->
              <div id="ligand-features-list" class="grid grid-cols-2 sm:grid-cols-3 gap-3"></div>
              <!-- Horizontal bars showing per-target contribution to score -->
              <h4 class="font-semibold text-base mt-4">Per-Feature Contributions</h4>
              <div id="contrib-list" class="mt-2 space-y-2"></div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>

  <script>
    // -------------------------------
    // Pharmacophore feature catalog
    // -------------------------------
    // Each feature type has a label and a color for visualization.
    const PHARMACOPHORE_FEATURES = {
      H_DONOR:       { name: "H-Bond Donor",    color: 0x42a5f5 },
      H_ACCEPTOR:    { name: "H-Bond Acceptor", color: 0xef5350 },
      HYDROPHOBIC:   { name: "Hydrophobic",     color: 0xffca28 },
      POSITIVE_ION:  { name: "Positive Ion",    color: 0x66bb6a },
      NEGATIVE_ION:  { name: "Negative Ion",    color: 0xab47bc }
    };

    // -------------------------------
    // Target pharmacophore (the ‚Äúpocket‚Äù)
    // -------------------------------
    // Fixed 3D positions for target features in this demo.
    const TARGET_PHARMACOPHORE = [
      { type: 'H_ACCEPTOR',   position: new THREE.Vector3(-4,  2,  0) },
      { type: 'HYDROPHOBIC',  position: new THREE.Vector3( 3, -3,  2) },
      { type: 'H_DONOR',      position: new THREE.Vector3( 5,  5, -1) },
      { type: 'NEGATIVE_ION', position: new THREE.Vector3(-2, -5, -3) }
    ];

    // -------------------------------
    // Scene state
    // -------------------------------
    let scene, camera, renderer, controls;
    const targetGroup = new THREE.Group(); // target feature meshes + helper
    const ligandGroup = new THREE.Group(); // ligand feature meshes
    const auxGroup    = new THREE.Group(); // grid or helpful decorations
    const pocketBox   = new THREE.Box3();  // padded AABB around target cluster

    let currentLigandFeatures = [];        // currently displayed ligand features
    let topHits = [];                      // top 5 hits by score (deep-cloned)
    let seeded = true;                     // toggle seeded RNG for reproducibility
    let rng = mulberry32(1337);            // default seed

    // -------------------------------
    // Seeded RNG for reproducible runs
    // -------------------------------
    // Mulberry32: small, fast, reasonably good for demo purposes.
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    function rand(){ return seeded ? rng() : Math.random(); }
    function randInt(min, max){ return Math.floor(rand() * (max - min + 1)) + min; }
    function randRange(a, b){ return a + (b - a) * rand(); }

    // -------------------------------
    // Three.js initialization
    // -------------------------------
    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();

      // Perspective camera for 3D view
      camera = new THREE.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 24);

      // Renderer with antialiasing for smooth edges
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setClearColor(0x111827);
      if (THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding; // nicer colors
      container.appendChild(renderer.domElement);

      // Basic lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(6, 10, 7.5);
      scene.add(dirLight);

      // OrbitControls for mouse/touch navigation (drag, wheel, pinch)
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 8;
      controls.maxDistance = 80;

      // Subtle grid to help orientation (XY plane)
      const grid = new THREE.GridHelper(60, 30, 0x334155, 0x1f2937);
      grid.rotation.x = Math.PI / 2;
      grid.position.z = -12;
      auxGroup.add(grid);

      // Group setup
      scene.add(targetGroup, ligandGroup, auxGroup);

      // Draw the fixed target and build the pocket AABB
      drawTargetPharmacophore();

      // Responsive resize
      window.addEventListener('resize', () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }, { passive: true });

      // Animation loop
      animate();
    }

    // Render loop (updates controls for smooth damping)
    function animate() {
      requestAnimationFrame(animate);
      controls && controls.update();
      renderer.render(scene, camera);
    }

    // -------------------------------
    // Render the target pharmacophore
    // -------------------------------
    function drawTargetPharmacophore() {
      targetGroup.clear();
      const targetList = document.getElementById('target-features-list');
      targetList.innerHTML = '';
      pocketBox.makeEmpty();

      // Add a torus knot for each target feature (purely visual)
      TARGET_PHARMACOPHORE.forEach(feature => {
        const def = PHARMACOPHORE_FEATURES[feature.type];
        const geometry = new THREE.TorusKnotGeometry(1.5, 0.25, 72, 10);
        const material = new THREE.MeshStandardMaterial({
          color: def.color, roughness: 0.35, metalness: 0.2, emissive: 0x000000
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(feature.position);
        targetGroup.add(mesh);

        // Grow pocket AABB around target features
        pocketBox.expandByPoint(feature.position);

        // UI card (legend) for each target feature
        const card = document.createElement('div');
        card.className = "flex items-center bg-gray-100 p-2 rounded-md";
        card.innerHTML = `<div class="w-4 h-4 rounded-full mr-3" style="background-color:#${def.color.toString(16).padStart(6,'0')}"></div>
                          <span class="font-medium">${def.name}</span>`;
        targetList.appendChild(card);
      });

      // Add padding to pocket and show a box helper (cyan)
      pocketBox.expandByScalar(3.0);
      const helper = new THREE.Box3Helper(pocketBox, 0x00ffff);
      targetGroup.add(helper);
    }

    // -------------------------------
    // Draw ligand features
    // -------------------------------
    function drawLigand(features) {
      ligandGroup.clear();

      // Core: a faint poly to give a sense of a molecule center (visual only)
      const coreGeom = new THREE.IcosahedronGeometry(1.1, 0);
      const coreMat  = new THREE.MeshStandardMaterial({ color: 0x9e9e9e, transparent: true, opacity: 0.22, roughness: 0.8, metalness: 0.05 });
      ligandGroup.add(new THREE.Mesh(coreGeom, coreMat));

      // Add colored spheres at each ligand feature position
      features.forEach(feature => {
        const def = PHARMACOPHORE_FEATURES[feature.type];
        const geom = new THREE.SphereGeometry(0.75, 32, 32);
        const mat  = new THREE.MeshStandardMaterial({ color: def.color, roughness: 0.5, metalness: 0.1 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.copy(feature.position);
        ligandGroup.add(mesh);
      });
    }

    // -------------------------------
    // Ligand generation (pseudo-random)
    // -------------------------------
    // Creates 3‚Äì6 random features within a cube around the target pocket.
    function generateRandomLigand() {
      const features = [];
      const numFeatures = randInt(3, 6);
      const keys = Object.keys(PHARMACOPHORE_FEATURES);
      for (let i = 0; i < numFeatures; i++) {
        const type = keys[randInt(0, keys.length - 1)];
        const pos = new THREE.Vector3(
          randRange(-6, 6),
          randRange(-6, 6),
          randRange(-6, 6)
        );
        features.push({ type, position: pos, matched: false });
      }
      return features;
    }

    // -------------------------------
    // Simple ‚Äúoptimization‚Äù (local tweak)
    // -------------------------------
    // Slightly nudges each feature; keeps types the same.
    function optimizeLigand(baseFeatures) {
      return baseFeatures.map(feat => {
        const newPos = feat.position.clone();
        newPos.x += randRange(-1.2, 1.2);
        newPos.y += randRange(-1.2, 1.2);
        newPos.z += randRange(-1.2, 1.2);
        return { ...feat, position: newPos, matched: false };
      });
    }

    // -------------------------------
    // Score: match ligand features to target features
    // -------------------------------
    // Rules:
    //  - Only match features of the same type inside the pocket box.
    //  - Distance threshold = 3.5 √Ö; contribution scales linearly up to 25.
    //  - One ligand feature can match only one target feature.
    //  - Total score capped at 100.
    function calculateBindingScore(ligandFeatures) {
      // Reset match flags before scoring
      ligandFeatures.forEach(f => f.matched = false);

      const threshold = 3.5;          // √Öngstr√∂m threshold (visual scale units)
      let score = 0;
      const contributions = [];        // per-target feature contribution record
      let matches = 0;

      // For each target feature, find the best available ligand feature (same type)
      TARGET_PHARMACOPHORE.forEach(targetFeat => {
        let bestMatchDist = Infinity;
        let bestMatchLigand = null;
        let bestIdx = -1;

        ligandFeatures.forEach((ligandFeat, idx) => {
          const typeMatch = ligandFeat.type === targetFeat.type;
          const insidePocket = pocketBox.containsPoint(ligandFeat.position);
          if (typeMatch && !ligandFeat.matched && insidePocket) {
            const dist = targetFeat.position.distanceTo(ligandFeat.position);
            if (dist < bestMatchDist) { bestMatchDist = dist; bestMatchLigand = ligandFeat; bestIdx = idx; }
          }
        });

        // Score contribution if within threshold
        if (bestMatchLigand && bestMatchDist < threshold) {
          const contrib = (threshold - bestMatchDist) / threshold * 25; // max 25 per target
          score += contrib;
          matches += 1;
          ligandFeatures[bestIdx].matched = true;
          contributions.push({
            target: targetFeat.type,
            distance: bestMatchDist,
            contribution: contrib
          });
        } else {
          // No match found for this target feature
          contributions.push({ target: targetFeat.type, distance: null, contribution: 0 });
        }
      });

      // Sanity clamp
      score = Math.min(Math.max(score, 0), 100);

      return { score, contributions, matches };
    }

    // -------------------------------
    // UI updates for results
    // -------------------------------
    function updateResultsUI(scoreObj, features) {
      const { score, contributions, matches } = scoreObj;

      // Reveal result panel and update key numbers
      document.getElementById('results-panel').classList.remove('hidden');
      document.getElementById('score').textContent = score.toFixed(2);

      // Basic interpretation bands (purely instructional)
      let interpretation = "Poor match. Unlikely to bind.";
      if (score > 70)      interpretation = "Excellent match! High potential for binding.";
      else if (score > 40) interpretation = "Good match. Shows binding potential.";
      else if (score > 15) interpretation = "Fair match. Some features align.";
      document.getElementById('score-interpretation').textContent = interpretation;

      // Show ‚Äúx / total matched‚Äù
      document.getElementById('match-count').textContent =
        `${matches} / ${TARGET_PHARMACOPHORE.length} target features matched`;

      // Render ligand feature cards (matched ones get green highlight)
      const ligandList = document.getElementById('ligand-features-list');
      ligandList.innerHTML = '';
      features.forEach(feat => {
        const def = PHARMACOPHORE_FEATURES[feat.type];
        const card = document.createElement('div');
        card.className = "feature-card flex items-center bg-gray-100 p-2 rounded-md text-sm";
        if (feat.matched) card.classList.add('matched');
        card.innerHTML = `<div class="w-3 h-3 rounded-full mr-2" style="background-color:#${def.color.toString(16).padStart(6,'0')}"></div>
                          <span class="font-medium">${def.name}</span>`;
        ligandList.appendChild(card);
      });

      // Render per-feature contribution bars
      const contribList = document.getElementById('contrib-list');
      contribList.innerHTML = '';
      contributions.forEach(c => {
        const def = PHARMACOPHORE_FEATURES[c.target];
        const row = document.createElement('div');
        row.innerHTML = `
          <div class="flex justify-between text-sm">
            <span class="flex items-center gap-2">
              <span class="inline-block w-3 h-3 rounded-full" style="background-color:#${def.color.toString(16).padStart(6,'0')}"></span>
              <span class="font-medium">${def.name}</span>
            </span>
            <span class="text-gray-600">${c.distance !== null ? c.distance.toFixed(2) + " √Ö" : "‚Äî"}</span>
          </div>
          <div class="w-full bg-gray-200 rounded h-2 mt-1">
            <div class="h-2 rounded" style="width:${Math.min(100, (c.contribution/25)*100)}%; background-color:#${def.color.toString(16).padStart(6,'0')}"></div>
          </div>
        `;
        contribList.appendChild(row);
      });

      // Show optimize button when there‚Äôs at least a moderate score
      document.getElementById('optimize-btn').classList.toggle('hidden', score < 40);
    }

    // -------------------------------
    // Maintain a top-5 hit list
    // -------------------------------
    function updateHitList(scoreObj, features) {
      const score = scoreObj.score;
      const minScore = topHits.length < 5 ? 0 : topHits[4].score;

      // Only keep good scores in top-5 (store deep clone to avoid mutation)
      if (score > minScore) {
        const cloned = features.map(f => ({ type: f.type, position: f.position.clone(), matched: f.matched }));
        topHits.push({ score, features: cloned, meta: { matches: scoreObj.matches, timestamp: Date.now() } });
        topHits.sort((a, b) => b.score - a.score);
        if (topHits.length > 5) topHits.pop();
        renderHitList();
      }
    }

    // Render hit list rows with Load buttons
    function renderHitList() {
      const container = document.getElementById('hit-list-container');
      container.innerHTML = '';
      if (topHits.length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">No hits recorded yet.</p>';
        return;
      }
      topHits.forEach((hit, index) => {
        const row = document.createElement('div');
        row.className = 'hit-list-row flex justify-between items-center bg-gray-100 p-2 rounded-md';
        row.dataset.index = index;
        row.innerHTML = `
          <span class="font-semibold">#${index + 1}</span>
          <span class="font-bold text-blue-600">${hit.score.toFixed(2)}</span>
          <span class="text-xs text-gray-500 hidden md:inline">${new Date(hit.meta.timestamp).toLocaleTimeString()}</span>
          <div class="flex gap-2">
            <button class="load-btn text-xs bg-gray-700 text-white px-2 py-1 rounded">Load</button>
          </div>
        `;
        container.appendChild(row);
      });
    }

    // -------------------------------
    // Run a screening pass with a generator (random or optimizer)
    // -------------------------------
    function runScreening(ligandGenerator) {
      screenBtn.disabled = true;
      optimizeBtn.disabled = true;
      loader.classList.remove('hidden');

      // Small timeout is purely for UI feedback (spinner)
      setTimeout(() => {
        currentLigandFeatures = ligandGenerator();
        drawLigand(currentLigandFeatures);

        const scoreObj = calculateBindingScore(currentLigandFeatures);
        updateResultsUI(scoreObj, currentLigandFeatures);
        updateHitList(scoreObj, currentLigandFeatures);

        screenBtn.disabled = false;
        optimizeBtn.disabled = false;
        loader.classList.add('hidden');
      }, 300);
    }

    // -------------------------------
    // Export/Import/Snapshot helpers
    // -------------------------------
    function exportHits() {
      // Convert topHits to a compact JSON shape (positions as plain numbers)
      const json = JSON.stringify(topHits.map(hit => ({
        score: hit.score,
        matches: hit.meta.matches,
        features: hit.features.map(f => ({ type: f.type, position: { x: f.position.x, y: f.position.y, z: f.position.z } }))
      })), null, 2);

      const blob = new Blob([json], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'pharmacophore_hits.json'; a.click();
      URL.revokeObjectURL(url);
    }

    function importHits(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (!Array.isArray(data)) throw new Error("Invalid format");

          // Keep only first 5 entries; coerce values into expected types
          topHits = data.slice(0, 5).map(item => ({
            score: Number(item.score) || 0,
            meta: { matches: Number(item.matches) || 0, timestamp: Date.now() },
            features: (item.features || []).map(f => ({
              type: f.type,
              position: new THREE.Vector3(f.position.x, f.position.y, f.position.z),
              matched: false
            }))
          }));
          topHits.sort((a,b)=>b.score-a.score);
          renderHitList();
        } catch (e) {
          alert("Failed to import: " + e.message);
        }
      };
      reader.readAsText(file);
    }

    function snapshotCanvas() {
      // Save current canvas as PNG
      const link = document.createElement('a');
      link.download = 'screening_snapshot.png';
      link.href = renderer.domElement.toDataURL('image/png');
      link.click();
    }

    // -------------------------------
    // DOM references & event listeners
    // -------------------------------
    const screenBtn        = document.getElementById('screen-btn');
    const optimizeBtn      = document.getElementById('optimize-btn');
    const loader           = document.getElementById('loader-container');
    const hitListContainer = document.getElementById('hit-list-container');
    const exportBtn        = document.getElementById('export-btn');
    const importInput      = document.getElementById('import-input');
    const clearBtn         = document.getElementById('clear-btn');
    const toggleSeedBtn    = document.getElementById('toggle-seed-btn');
    const snapshotBtn      = document.getElementById('snapshot-btn');

    // Button: screen new candidate (random ligand)
    screenBtn.addEventListener('click', () => runScreening(generateRandomLigand));

    // Button: optimize current ligand (local tweaks)
    optimizeBtn.addEventListener('click', () => runScreening(() => optimizeLigand(currentLigandFeatures)));

    // Click in hit list: load stored ligand and re-score
    hitListContainer.addEventListener('click', (e) => {
      const row = e.target.closest('.hit-list-row');
      if (!row) return;
      const index = parseInt(row.dataset.index);
      const hit = topHits[index];
      if (!hit) return;

      // Deep clone features to avoid mutation
      currentLigandFeatures = hit.features.map(f => ({ type: f.type, position: f.position.clone(), matched: false }));
      drawLigand(currentLigandFeatures);
      const scoreObj = calculateBindingScore(currentLigandFeatures);
      updateResultsUI(scoreObj, currentLigandFeatures);
    });

    // Export hits to JSON
    exportBtn.addEventListener('click', exportHits);

    // Import hits from JSON
    importInput.addEventListener('change', (e) => {
      if (e.target.files && e.target.files[0]) importHits(e.target.files[0]);
      e.target.value = ''; // reset input
    });

    // Clear hit list
    clearBtn.addEventListener('click', () => { topHits = []; renderHitList(); });

    // Toggle seeded randomness (updates seed hourly to avoid staleness when ON)
    toggleSeedBtn.addEventListener('click', () => {
      seeded = !seeded;
      if (seeded) rng = mulberry32(1337 + Math.floor(Date.now()/60000));
      toggleSeedBtn.textContent = `Seeded RNG: ${seeded ? 'ON' : 'OFF'}`;
    });

    // Save a PNG snapshot of the current canvas
    snapshotBtn.addEventListener('click', snapshotCanvas);

    // Kick off Three.js once the page is loaded
    window.addEventListener('load', () => { init3D(); });
  </script>
</body>
</html>
